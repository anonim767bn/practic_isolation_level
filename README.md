
### Практическая работа

0. ***Что такое транзакция? Что такое прерывание транзакций? Повторение транзакций?***

**Транзакция** - это способ работы с БД который гарантирует либо полное выполнение всех операций, либо откат к изначальному состоянию, что обеспечивает консистентность данных в базе.  
**Прерывание транзакции** - это досрочное завершение транзакции без сохранения ее изменений, что обычно происходит при ошибках или по явному запросу пользователя (ROLLBACK).  
**Повторение транзакций** - это повторная попытка выполнения транзакции, если предыдущая транзакция была прервана, с целью добиться успешного завершения.

1. ***Как запустить транзакцию? Как завершить транзакцию? Как откатить транзакцию? Как сохранить изменения, совершенные транзакцией?***

**Запустить транзакцию** можно ключевым словом *BEGIN* или *BEGIN TRANSACTION*.   
**Завершить транзакцию** можно ключевым словом *COMMIT*, *END* (с сохранением изменений) или *ROLLBACK* (без сохранения).
**Откатить транзакцию** можно с помощью ключевого слова **ROLLBACK**.  
**Сохранить изменения, совершенные транзакцией**, можно с помощью команды **COMMIT**.

2. ***Расшифруйте аббревиатуру ACID. Опишите, что означает каждая её часть.***

**Atomicity** (Атомарность) означает, что транзакция — это неделимое целое: либо она выполняется полностью, либо не выполняется совсем.  
**Consistency** (Согласованность) означает, что данные в базе данных будут согласованными как до, так и после завершения транзакции.  
**Isolation** (Изоляция) означает, что все транзакции выполняются независимо друг от друга. Промежуточные состояния данных не видны другим транзакциям, пока данная транзакция не завершится.  
**Durability** (Долговечность) означает, что после успешного выполнения транзакции изменения гарантированно сохранятся в базе данных, даже если произойдет сбой системы.

3. ***Что такое savepoint? Как его использовать?***

**Savepoint** - это механизм создания промежуточных точек сохранения внутри одной транзакции. Он позволяет откатить транзакцию не целиком, а до определенной точки сохранения.  
**Объявить savepoint** можно командой `SAVEPOINT savepoint_name;`.  
Чтобы **откатиться** до savepoint, используйте команду `ROLLBACK TO SAVEPOINT savepoint_name;`.  
Чтобы **удалить** savepoint, используйте команду `RELEASE SAVEPOINT savepoint_name;`.

4. ***Опишите уровень Read Committed.***

Уровень изоляции **Read Committed** защищает от грязного чтения (dirty read), гарантируя, что транзакции читают только закоммиченные изменения других транзакций. Однако он не защищает от неповторяющегося чтения (non-repeatable read) и фантомного чтения (phantom read), так как данные могут изменяться и коммититься другими параллельными транзакциями, что приводит к изменению результатов выполнения запросов в текущей транзакции.

5. ***Опишите уровень Serializable.***

Уровень изоляции **Serializable** является самым строгим и гарантирует, что транзакции выполняются последовательно, как если бы они выполнялись одна за другой, а не параллельно. Это предотвращает все виды аномалий: грязное чтение, неповторяющееся чтение и фантомное чтение. Однако такой уровень изоляции может существенно замедлить работу системы из-за необходимости управления многочисленными блокировками и синхронизациями.

6. ***Чем уровень Repeatable Read отличается от уровня Read Committed?***

Уровень изоляции **Repeatable Read** предотвращает грязное чтение и неповторяющееся чтение, гарантируя, что данные, прочитанные одной транзакцией, не изменяются до завершения этой транзакции. Однако он не защищает от фантомного чтения.  
В отличие от него, уровень **Read Committed** предотвращает только грязное чтение, но допускает неповторяющееся и фантомное чтение.

7. ***Что такое грязное чтение?***

**Грязное чтение (dirty read)** - это ситуация, при которой одна транзакция читает незакоммиченные изменения, совершенные другой транзакцией. Если вторая транзакция откатывается, данные, считанные первой транзакцией, окажутся некорректными, что может привести к ошибкам и неконсистентности данных в базе данных.

8. ***Чем обычный "SELECT ..." отличается от "SELECT ... FOR UPDATE"?***

Обычный `SELECT` считывает данные из базы данных без наложения блокировок на считанные данные.  
`SELECT ... FOR UPDATE` накладывает **эксклюзивную блокировку (exclusive lock)** на все строки, выбранные в запросе, что предотвращает их изменение другими транзакциями до завершения текущей транзакции.

9. ***Что такое MVCC? Как работает? Зачем это нужно?***

**MVCC (Multiversion Concurrency Control)** - это механизм управления параллелизмом в системах управления базами данных, который позволяет транзакциям работать с несколькими версиями данных. Вместо блокировки данных для чтения и записи, MVCC позволяет транзакциям читать данные в состоянии на момент их начала, создавая новые версии данных при их изменении. Это позволяет избежать блокировок чтения и повышает производительность за счет уменьшения конфликтов между транзакциями. MVCC обеспечивает изоляцию и согласованность данных без значительного снижения производительности.

10. ***Какие уровни изоляции (обычно) замедляют быстродействие? Какие уровни безопаснее?***

Сильнее всех замедляют быстродействие те уровни, которые обеспечивают большую безопасность данных - **Serializable** и **Repeatable Read**, так как требуют большего управления блокировками и синхронизациями.   
Уровни изоляции **Read Committed** и **Read Uncommitted**, обеспечивают большее быстродействие, но меньшую безопасность данных.  
Поэтому важно искать компромисс быстродействия и безопасности.


## 11

* **RC**: Обе транзакции завершились успешно, итоговые данные в таблице изменились на

|id|value|
|--|--|
|1|1|

Второму клиенту, чтобы обносить данные в таблице пришлось ожидать завершения транзакции первого клиента.
* **RR**: первая транзакция завершилась успешно и обновила данные в таблице, а вторая после ожидания завершения первой выдала ошибку **could not serialize access due to concurent update**, после чего я сделал **ROLLBACK** во второй транзакции.  
Итоговые данные в базе:  

|id|value|
|--|--|
|1|1|

* **S**: Тот же результат, что на **RR**


## 12

* **RC**: Обе транзакции завершились успешно, вторая транзакция при обновлении данных ожидала окончания первой транзакции.
Итоговые данные в базе:  

|id|value|
|--|--|
|1|2|
* **RR**: Вторая транзакция перед обновлением данных ожидала окончание первой транзакции, а затем выдала ошибку **could not serialize access due to concurrent update**
* **S**: То же что и с **RR**

## 13
* **RC**: Обе транзакции выполнились успешно, блокировок не происходило. В первой транзакции добавилась запись с *id* = 2, а во второй с *id* = 3.
Итоговые данные в базе, после завершения обеих транзакций:

 id | value 
|---|------|
  1 |     0
  2 |     1
  3 |     0
* **RR**: В обеих транзакциях операция **insert** прошла успешно, но с **select** возникли проблемы. В первой транзакции он выполнился и выдал следующий результат:

 id | value|
----|------|
  1 |     0|
  2 |     1|

А во второй транзакции при попытке сделать **select** выдалась следующая ошибка - **current transaction is aborted, commands ignored until end of transaction block**  
В конце концов вторая транзакция при попытке ее завершить сделала **ROLLBACK**.
* **S**: обе траназкции выполнились полностью без ошибок, вторая транзакция дала всего лишь одно предупреждение **there is no transaction in progress**  
Итоговые данные в базе:

 id | value 
----|------
  1 |     0
  2 |     1
  3 |     0


## 14
* **RC**:
В первой транзакции на шаге 5 получаем следующий вывод:

 id | value 
-----|-------
  1 |     1

Во второй:
 id | value 
-----|-------
  2 |     


Итоговые данные в базе:
 id | value 
----|-------
  1 |     1
  2 |      

Все транзакции выполнились без ошибок и блокировок.

* **RR**: Абсолютно также как и **RC**
* **S**: Первая транзакция выполнилась без ошибок, а вторая вернула ошибку при попытке сделать **select** на 6 шаге
```
ERROR:  could not serialize access due to read/write dependencies among transactions
DETAIL:  Reason code: Canceled on identification as a pivot, during commit attempt.
HINT:  The transaction might succeed if retried.
```

на 5 шаге получили вывод:

 id | value 
-----|-------
  1 |     1

Итоговые данные в базе:

 id | value 
-----|-------
  1 |     1




## 15
Обе транзакции выполнились без ошибок на всех уровнял изоляции, так как они последовательны.  
Итоговые данные в базе:
 id | value|
|---|------|
  1 |     1
  2 |     1
  3 |     2
  4 |     4

## 16. В чём отличие работы уровней изоляции в стандарте SQL и в субд PostgreSQL? 
* В **PostgreSQL** не существует уровня изоляции **Read Uncommited**, но в синтаксис все еще позволяет начать транзакцию этого уровня, хотя все равно будет использоваться уровень **Read Commited** (это сделано для обратной совместимости).  
* Опытным путем понял, что уровень изоляции **Repeatable Read** в **PosgreSQl** защищает не только от **non-repeatable** read но и от **phantom read**.
